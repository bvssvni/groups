
        //////  //////    /////   //   //  /////   ///////
      //        //  //  //   //  //   //  //   // //
     //  ///  /////    //   //  //   //  //////   //////
    //   //  //  //   //   //  //   //  //            //
   //////   //   //   /////    /////   //       //////

by Sven Nilsen 2012.

Groups is a library written in C for group-oriented programming.

WHATÊISÊGROUP-ORIENTEDÊPROGRAMMING?

Group oriented programming is different from object-oriented programming because you use techniques to optimize search for data in groups instead of looking for a specific object. The best tool for group searching is something called "bitstreams", which allows you to look up a group of objects faster than checking each of them. While the full extend of group-oriented programming is too large for me to write in plain C, I created this library to provide the basic need of computing with bitstreams.

Let us say we have a database of life forms stored group-oriented. To store group-oriented data means that we have no principle of what a "plant" or a "tree" or "animal" is like in object-oriented thinking, but rather the groups of 'four-legged', 'two-eyes', 'tail' or 'leaves'. Group-oriented programming is concerned about the detailed facts and the actual use of it is decided through runtime either by algorithm or a user.

If you have a class in object-oriented programming, you can write an equivalent in group-oriented programming. For example:

Person = FirstName + LastName

Object-oriented programming languages are not designed for group-orientation, they lack "bitstreams" and they have not complete set of Boolean algebra operators that are logical to use. Most fields studying Boolean algebra also lack the notion of EXCEPT, which is A*!B or written in my notation as A-B where the minus is evaluated after the pluss. In programming languages with support for overloading, you can actually write "A+B-C" when the compiler evaluates the expression from left to right. EXCEPTÊis important because nobody says "Give me not one icecream". If you try to write a group-oriented operating system using bitstreams you would find out that inverting bitstreams on direct computer memory is a dangerous thing, but using EXCEPTÊis safe since AND immediately follows NOT.

In group-oriented programming, you can create much more complex rules of what an object is because you have the concept of EXCEPT built into it:

Bird = Feather * ( CanFly + Penguin + Kiwi ) - ( CanDive - Penguin )

Of course this is not a complete description of a bird, that's why group-oriented programming allows you to change the rules independent from the data.

BITSTREAM

A bitstream is a list of numbers or comparable objects that form a continious value between the positions instead of at the positions.


          on              off   on    off            on   off
=========>----------------<====>------<=============>-----<==

We say that a new value marks the change. If you write a bitstream in numerical form, you can see it as a list of ever increasing numbers:

0->10 12->14 17->21 30->

If a bitstream ends with odd number of terms, it means the size of it is infinite. This is perfectly valid as long as you use 'bitstream_Abs' where you pass a maximum size. If you never use 'bitstream_Invert' you will never get infinite size and you can use 'bitstream_Size' instead.

STEPÊ1

#include "memgroups.h"

Because C is not garbage collected, something that makes complicated expressions difficult to program, I have created a stack that does this for you. First you declare the bitstreams you want to use. How you get them depends on on your application design, but basically it is just like a table of numbers that describe where in a collection of data there is a 'property Feather' or 'property CanFly' and so on.

bitstream* Feather, CanFly, Penguin, Kiwi, CanDive; // input
bitstream* Bird; // output

STEPÊ2

You create the garbage collector. You can do this at start of application if you like, because you can roll back to a specified size of the stack. Get the level of the stack before you start doing the calculations. Later you will need it to free the unused objects. It is important you call it 'gc' or else you will not be able to use the macroes to simplify the expression.

gcstack* gc = gcstack_Init(gcstack_Alloc());

int level = gc->length; // alternative: int gcstack_Start(gc).

STEPÊ3

Now we do the calculations, it is a good idea to write what you wanted in a comment, in case you need to debug it. When you set a pointer, you MUST pop it from the stack immediately, or else it will be released.

// Bird = Feather * ( CanFly + Penguin + Kiwi ) - ( CanDive - Penguin )
Bird = _ex( 
	_and( Feather, _or3( CanFly, Penguin, Kiwi ) ) ,
	_ex( CanDive, Penguin )
	);
// This is important to avoid releasing the memory of your result.
// Always do this right after your function call.
gcstack_Pop(gc, Bird);

STEPÊ4

We tell the stack to release all objects at this level and above. If you don't need the stack anymore, call first 'gcstack_Delete' and then free the pointer. If you have forgotten to call 'gcstack_End' it will release it for you.

// Release objects at this level and above.
gcstack_End(gc, level);

// Releases the remaining data on the stack.
gcstack_Delete(gc);
free(gc);

PERFORMANCE

To compare performance, you can make a for-loop and execute the code 2^X times until it does about 10 seconds. If it is below 7.5, you add one to X and if it is above 15 you subtract one. The X you end up with can be written down and used to compare different techniques or examples.

CREDITS

Based on research my own research and written by myself.
