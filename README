        //////  //////    /////   //   //  /////   ///////
      //        //  //  //   //  //   //  //   // //
     //  ///  /////    //   //  //   //  //////   //////
    //   //  //  //   //   //  //   //  //            //
   //////   //   //   /////    /////   //       //////

by Sven Nilsen 2012.

Groups is a library written in C for group-oriented programming.

To learn more aboug group-oriented programming, skip to "What is group-oriented programming".

CONTENT

This library contains:
- Bitstreams for group searching using Boolean algebra ( OR, AND, EXCEPT ).
- Garbage collector stack for containing items making calculation and organizing data easier ( double-linked list ).
- QuickSort for items supporting garbage collected items ( to sort the order at the stack automatically ).
- BinarySearch for looking up items.
- Groups for storing and retrieving data. (See GROUPSÊSTORAGE)

Because bitstreams gets messy with pointers, I created a garbage collector stack that cleans up all objects created after a certain level, unless they have been popped from the stack. You can extract pointers from the stack and sort it with the QuickSort method. The sorting uses a special Swap method that swaps the items first byte for byte and then swaps them on the stack. This means you can use a gcstack for general data management that are fast, cleans itself and can be sorted in any order.

WHAT IS GROUP-ORIENTED PROGRAMMING?

Group oriented programming is different from object-oriented programming because you use techniques to optimize search for data in groups instead of looking for a specific object. The best tool for group searching is something called "bitstreams", which allows you to look up a group of objects faster than checking each of them. Bitstreams can be used, theoretically, to solve any problem.

In object-orientation, you start with a class and then fill in the properties you associate with the object. The problem is that if you need to add a property which the rest of objects of same type doesn't have, then you need to inherit the object and then add it. This is to keep algorithms from sucking in data that will crash the program. Before each task, you have to browse the application structure and operate on a specific part. When the application grows, there is an increasing amount of exceptions to the initial design.

Group-orientation is like object-orientation except for the classes, pluss that each property is tracked with a bitstream. If you need a new type of objects, you just add the property you need to make them special. When the algorithms want data, they combine properties together represented as bitstreams. When we think of a 'chair', we can identify it with a physical shape, but when we think of 'furniture' this is something we tag to the 'chair' instead of having a rule of how to identify it. Because properties can both be recognized and created out of thin air, we can say that any way to combine a collection itself is a property, because it can be tagged as a flag on each member.

If you have a class in object-oriented programming, you can write an equivalent in group-oriented programming. For example:

Person = FirstName + LastName

Try to think of 'Person' as a property and not an object. We have not given 'Person' identities. A group is a collection of objects that share same properties, but the variable element in the group is the identity. If we have no way to distinguish the members of a group from each other, then the members have no identity. Classes is a way to create groups, but objects is way to give identity. In group-oriented programming you treat classes as variables of bitstreams. You have the same separation of data from types, only that you can do Boolean operations on the types. One thing you can't do in object-oriented programming is to create a class that does not contain a property, like 'I create a party for everybody, but you are not invited'. This operation is called EXCEPT.

In group-oriented programming, you can create much more complex rules of what an object is because you have the concept of EXCEPT built into it:

Bird = Feather * ( CanFly + Penguin + Kiwi ) - ( CanDive - Penguin )

Notice that exceptions are written as minus, but to the right of the other terms. This is important, because minus in this algebra got lower precedence than addition, it can be converted to A-B = A*!B and moved outside paranthesis. Minus means it operates on all other terms on the same level, not only the one to the left. The scholars doesn't believe minus exists in Boolean algebra, but it is an important part of the human common sense and to operate bitstreams safely on "infinite" datasets, like whole computer memory. With OR, AND and EXCEPT you can perform all operations except those who results in inverted collections.

In group-orientation, you start with a blank page for all data where properties can be tied together, but not under strict rules. This sounds like chaos, but in practice it gives you much more control. For hard-core object-oriented programmers this might sound crazy, but learning new things makes you a better programmer.

Just think of it for a moment: If you write an algorithm that only work if the object got X and Y and these two can be set to NULL, then if you feed the algorithm with a class of objects that might have NULL in X and Y, the algorithm will fail. Therefore, you add a sentence in the beginning of the algorithm "if (X == NULL || Y == NULL) return;" to filter out problematic objects.

Why not do it differently? If you want an algorithm to work in a specific case, why not let the programmer decide what kind of objects it can operate on? If he needs only X, then he can take X. If he need X and Y, he can require both. If you can control the data available for searching, then the algorithm can not eat data it is not supposed to eat. Most algorithms take either few variables or operate on general data structures. To calculate the length of a vector takes few arguments, while exporting a comma separated file is a general task. This means that if you find a way to compute subgroups of the entire dataset fast, then you can compose a virtual list of objects or array of primitive types for the algorithm on the fly. This is what bitstream does.

"What a minute, this sounds like SQL!" Yes, it does because SQL uses the same algebra on data, only it separates tables just like object-oriented programming does. With bitstreams you can preprocess specific parts of the query without moving the data. A bitstream is hundreds of times faster than SQL. The usage of SQL is to get data to the application, while bitstreams is to get data to the algorithms.

BITSTREAM

A bitstream is a list of numbers or comparable objects that form a continious value of true between the positions instead of 'at' the positions.


          on              off   on    off            on   off
=========>----------------<====>------<=============>-----<==

We say that a new value marks the change. If you write a bitstream in numerical form, you can see it as a list of ever increasing numbers:

0->10 12->14 17->21 30->

If a bitstream ends with odd number of terms, it means the size of it is infinite. This is perfectly valid as long as you use 'bitstream_Abs' where you pass a maximum size. If you never use 'bitstream_Invert' you will never get infinite size and you can use 'bitstream_Size' instead.

STEP 1

#include "memgroups.h"

Because C is not garbage collected, which makes complicated expressions difficult to program, I have created a stack that does this for you. First you declare the bitstreams you want to use. How you get them depends on on your application design, but basically it is just like a table of numbers that describe where in a collection of data there is a 'property Feather' or 'property CanFly' and so on.

bitstream* Feather, CanFly, Penguin, Kiwi, CanDive; // input
bitstream* Bird; // output

STEP 2

You create the garbage collector. You can do this at start of application if you like, because you can roll back to a specified size of the stack. Get the level of the stack before you start doing the calculations. Later you will need it to free the unused objects.

gcstack* gc = gcstack_Init(gcstack_Alloc());

int level = gcstack_Start(gc);

STEP 3

Now we do the calculations, it is a good idea to write what you wanted in a comment, in case you need to debug it.

// Bird = Feather * ( CanFly + Penguin + Kiwi ) - ( CanDive - Penguin )
bitstream* tmp = bitstream_Or( gc, CanFly, Penguin );
tmp = bitstream_Or( gc, tmp, Kiwi );
tmp = bitstream_And( gc, tmp, Feather );
bitstream* tmp2 = bitstream_Except( gc, CanDive, Penguin );
Bird = bitstream_Except( gc, tmp, tmp2 );

// Pop the item you need is important to avoid releasing the memory.
// Always do this right after your function call.
gcstack_Pop(gc, Bird);

STEP 4

We tell the stack to release all objects at this level and above. If you don't need the stack anymore, call first 'gcstack_Delete' and then free the pointer. If you have forgotten to call 'gcstack_End' it will release it for you.

// Release objects at this level and above.
gcstack_End(gc, level);

// Releases the remaining data on the stack.
gcstack_Delete(gc);
free(gc);	// Remember to release the pointer too!

4 TYPICAL ERRORS:

1.	Add 'gcstack_item gc;' at start of struct to make it
	collectable for a garbage collector (gcstack).
	===> NOT 'gcstack_item* gc;' <=== (don't add as pointer)
	If you get a bug which you have no idea is coming from,
	then check for this mistake FIRST.

2.	When using gcstack to collect items inside functions,
	pop the ones you need IMMEDIATELY after calling the function.
	If you call a new gcstack_Start before popping,
	the gcstack will release one item too much at the stack
	and create untracable bugs. If you got unexplainable errors,
	check this SECOND.

3.	If you are dealing with inverted bitstreams, you should
	use EXCEPT instead if the set is unlimited.
	If you have odd length of the bitstream, it means it is infinite.
	If you have even length of the bitstream, then it is finite.
	EXCEPT is faster than taking NOT and then AND.

4.	bitstream_Delete and gcstack_Delete does not free the pointers,
	only the pointers in the structure. Bitstream frees the
	array that contain the data. GCStack frees the members
	on the stack.

ITERATINGÊTHROUGHÊAÊBITSTREAM

A bitstream is naturally divided into blocks, so you need to jump twice. It is normal to suptract 1 from the length to avoid reading outside memory for inverted bitstreams. If you always use AND,ÊOR,ÊEXCEPTÊand never INVERT, then you don't have to worry about this. Inside the loop for the blocks you need another loop to step 1 from the start of the block to the end. This becomes very messy if you write nested iterations through a bitstream. Therefore you can copy a snippet in 'readability.h' that let's you write like this:

foreach (X) {
	if (_pos(X) > 1000)
		_break(X);
} end_foreach (X)

Remember 'end_foreach' after the last bracket.

You can also loop backward with foreach_backward. The parameter to the macro is to make sure the command does the right thing in nested iterations. All variables generated with the macro starts with '__' to not interfer with other code.

'continue' works just as it would in a single for-loop, but '_break' is special because it jumps after the end of the foreach loop. You can jump directly out of nested loops to the top.

You can also write '_pos(X)++' to increment or '_pos(X)--' to decrement. It will be aligned when it reaches the next block.

You can not use two foreach on the same variable name in the same method. The reason is that the 'end_foreach' contains a label that is generated by the variable name. Declare a new 'bitstream' pointer and use it for the new loop. This allows nested loop with itself.

bitstream* X2 = X;
foreach (X2)
	...

GROUPSÊSTORAGE

The preferred way to get and store data is through an structure called "Groups" which can store data of any kind. It is recommended to keep data that is readable in text format in Groups and for example using 'int' to refer to data stored outside, for example images. It is not recommended to use pointers to other members, because then you have to check every single object. Use an 'int' instead to the index of that member.

At the moment, there are 4 'native' types in Groups:
- int, default value -1, used for relations and table indices.
- bool, default value 0, used for tagging objects.
- double, no default value, used for numbers.
- string (const char*), default value NULL, used for text info.

If you deal with numbers use double, even if you only need integer values. It is faster than int on update with array because it does not have to check for default value.

A default value is a value a property can have but still not be counted as 'in' the group. This is very useful, for example in relations using 'int' you can get the members that has an active relation. If you want all objects of a type, then you can use a 'bool' property.

'int' and 'bool' are both int in C, but they have different default value. 'bool' is compatible with how C uses true and false conditions. 'int' is compatible with search for position in text or tables.

INSERTINGÊNEWÊMEMBERS

member* me = member_Init(member_AllocWithGC(NULL));
member_AddString(me, propId, "Hello World!");
groups_AddMember(g, me);

The reason you pass NULL to 'member_AllocWithGC' is that when we add it to Groups it will be pushed on a gcstack containing all members. On insert it will loop through the properties and update the bitstreams. Inserting many new members is a heavier task than updating many members with new values.

EXTRACTÊDATA

The way you work with data in Groups is 'vertically' compared to object-oriented code. The advantage of this is that you can copy & paste snippets of code between complete different application or port easily from another language.

int length = bitstream_Size(X);
double* xs = groups_GetDoubleArray(g, X, propX);
double* ys = groups_GetDoubleArray(g, Y, propY);
for (int i = 0; i < length; i++)
	// Do something.
free(xs);
free(ys);

UPDATINGÊMEMBERS

There is two types of updates you can make. The first one is to update many members with one value.

groups_SetDouble(g, X, propX, 0.0);

The second is to update with an array.

groups_SetDoubleArray(g, X, propX, xn, xValues);

When updating with arrays, you need to be careful. The best way is to use the same array and same bitstream as you extracted before the update.

PROPERTYÊIDÊANDÊTYPE

All other types will be of 'unknown'. Those types can not be used as easily as the native. When you add a new property, the native types returns the property id of an existing if it has same name and type. This can not be done with 'unknown' types because there is way to check if it is the same type. Therefore, use native types when possible.

The type of a property is stored within the id itself. It uses same system as in image processing algorithms where you have x + y*stride. This format is easy to use. It requires only propId to extract both values. The type is found by 'propId / TYPE_STRIDE' and the property index by 'propId % TIME_STRIDE'. You can get these by including 'memgroups.h' or 'readability.h'.

PERFORMANCE

To compare performance, you can make a for-loop and execute the code 2^X times until it run approximately 10 seconds. If it is below 7.5, you add one to X and if it is above 15 you subtract one. The X you end up with can be written down and used to compare different techniques or examples.

CREDITS

Based on research my own research and written by myself (Sven Nilsen).

Thanks to seeeoneself for support.

